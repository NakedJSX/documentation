export default
    () =>
    <Topic name="Client Javascript" path="client-js">
        <p>
            NakedJSX can compile client JavaScript to execute in the browser, which has two distinct advantages over linking to externally built JavaScript:
        </p>
        <ul>
            <li>NakedJSX compiled client JavaScript can use inline JSX</li>
            <li>The CSS deduplication system allows client and page JSX to share generated classes</li>
        </ul>
        <p>
            By default, compiled client JavaScript is placed in a <Tag>script</Tag> tag
            at the end of the <Tag>body</Tag>. It can also be configured to place it in an asset
            file, with a <Tag>script</Tag> linking to it automatically added to the document <Tag>head</Tag>.
        </p>
        <p>
            There are four ways to get NakedJSX to compile client JavaScript:
        </p>
        <ul>
            <li>A dedicated <Inline>*-client.mjs</Inline> file</li>
            <li>The <Inline lang="js">Page.AppendJs()</Inline> function</li>
            <li>Adding inline event handlers to JSX elements</li>
            <li>The <Inline lang="js">Page.AppendJsCall()</Inline> function</li>
        </ul>
        <p>
            A dedicated file is usually the right choice for large amounts of code,
            with the other methods used for event handlers, JSX function support functions
            and other snippets.
        </p>

        <Topic name="Adding via Dedicated File" path="file">
            <p>
                Files matching the pattern <Inline>*-client.mjs</Inline> are automatically
                compiled and placed into a script tag in the HTML generated by the corresponing <Inline>*-page.jsx</Inline>.
            </p>
            <p>
                Modern JavaScript can be used, with the result being transpiled to a browser-compatible
                format when necessary.
            </p>
            <Example captureOutput={['example', 'client-js', 'dedicated-file']}>
                <Example.Src lang="javascript" filename="src/index-client.js">{
`var p = document.getElementById('click-me');
var clickCounter = 0;
p.onclick =
    () =>
    {
        p.appendChild(document.createElement('br'));
        p.appendChild(document.createTextNode(\`Click \${++clickCounter}: This content was dynamically added to the DOM.\`));
    };`
                }</Example.Src>
                <Example.Src lang="javascript" filename="src/index-page.jsx">{
`import { Page } from '@nakedjsx/core/page'

Page.Create('en');
Page.AppendBody(
    <>
        <h1>Title</h1>
        <p id="click-me">Click Me!</p>
    </>
);
Page.Render();`
                }</Example.Src>
                <p>
                    As you can see, the JavaScript output is minified (although formatted a little because we built with <Inline lang="shell">--pretty</Inline>):
                </p>
            </Example>
            <p>
                Minification is great for production builds, but not during development. In development mode
                (<Inline lang="shell">--dev</Inline>) minification is disabled and sourcemaps are generated,
                providing a comfortable debugging experience.
            </p>
    </Topic>

    <Topic name="Adding via Page.AppendJs()" path="page-append-js">
        <p>
            <Inline lang="js">Page.AppendJs(code, options)</Inline> adds JavaScript to the page for the browser to execute.
        </p>
        <p>
            By default, it won't add the same JavaScript twice. This is useful when implementing a JSX function that requires
            a client JavaScript helper function - the JSX function can just blindly add the client function every time.
        </p>
        <p>
            If <Inline lang="js">{`{ allowDuplicate: true }`}</Inline> is passed to <Inline lang="js">options</Inline>,
            then it will add the code regardless of whether it has been added before.
        </p>
        <p>
            <Inline lang="js">Page.AppendJs()</Inline> handles multiple forms of <Inline lang="js">code</Inline> argument:
        </p>
        <ul>
            <li>A string containing JavaScript code</li>
            <li>A function with a name</li>
            <li>A anonymous function or an arrow function</li>
        </ul>

        <Example captureOutput={['example', 'client-js', 'append-js', 'string']}>
            <p>
                The content of a string argument will be added directly:
            </p>
            <Example.Src lang="javascript" filename="src/index-page.jsx">{
`import { Page } from '@nakedjsx/core/page'

Page.Create('en');
Page.AppendJs(\`
    function clicked()
    {
        alert('You clicked!');
    }
    document
        .getElementById('clicky-p')
        .addEventListener('click', clicked);
    \`);
Page.AppendBody(
    <>
        <h1>String Argument</h1>
        <p id="clicky-p">Click Me!</p>
    </>
    );
Page.Render();`
            }</Example.Src>
        </Example>

        <Example captureOutput={['example', 'client-js', 'append-js', 'named-function']}>
            <p>
                A named function will be added with name intact:
            </p>
            <Example.Src lang="javascript" filename="src/index-page.jsx">{
`import { Page } from '@nakedjsx/core/page'

Page.Create('en');
Page.AppendJs(
    function clicked()
    {
        alert('You clicked!');
    });
Page.AppendJs(\`
    document
        .getElementById('clicky-p')
        .addEventListener('click', clicked);
    \`);
Page.AppendBody(
    <>
        <h1>Named Function</h1>
        <p id="clicky-p">Click Me!</p>
    </>
);
Page.Render();`
            }</Example.Src>
        </Example>

        <Example captureOutput={['example', 'client-js', 'append-js', 'anon-function']}>
            <p>
                The <em>body</em> of an unnamed or arrow function will be added as top level code:
            </p>
            <Example.Src lang="javascript" filename="src/index-page.jsx">{
`import { Page } from '@nakedjsx/core/page'

Page.Create('en');
Page.AppendJs(
    function clicked()
    {
        alert('You clicked!');
    });
Page.AppendJs(
    () =>
    {
        document
            .getElementById('clicky-p')
            .addEventListener('click', clicked);
    });
Page.AppendBody(
    <>
        <h1>Anon Function</h1>
        <p id="clicky-p">Click Me!</p>
    </>
);
Page.Render();`
            }</Example.Src>
        </Example>
    </Topic>

<Topic name={'Adding via Inline Event Handlers'} path="on-event-handler">
    <p>
        It's also possible, and quite clean, to add client JavaScript using classic inline event handlers on JSX elements:
    </p>
    <Example captureOutput={['example', 'client-js', 'inline-event-handler']}>
        <Example.Src lang="javascript" filename="src/index-page.jsx">{
`import { Page } from '@nakedjsx/core/page'

Page.Create('en');
Page.AppendJs(
    function clicked()
    {   
        alert('You clicked!');
    });
Page.AppendBody(
    <>
        <h1>Event Handler</h1>
        <p onClick="clicked()">Click Me!</p>
    </>
    );
Page.Render();`
            }</Example.Src>
        </Example>
        <p>
            The minified output is a little different here, as the compiler needs to set <Inline lang="js">this</Inline> to the element
            with the inline event handler, and it also needs to pass the event to the handler. A future version of
            NakedJSX may parse the inline handler for references to <Inline lang="js">this</Inline> and <Inline lang="js">event</Inline> and
            simplify the generated code accordingly.
        </p>
    </Topic>

    <Topic name="Adding via Page.AppendJsCall()" path="page-append-js-call">
        <p>
            A common pattern is to pass a named function to <Inline lang="js">Page.AppendJs()</Inline>, and then generate a
            series of calls to that function with differing arguments.
        </p>
        <p>
            While it is possible to manually generate a JavaScript string containg the calls and
            then pass that string to <Inline lang="js">Page.AppendJs()</Inline>, NakedJSX
            provides an easier way.
        </p>
        <p>
            <Inline lang="js">Page.AppendJsCall(functionName, ...args)</Inline> accepts the name of a function followed
            by a series of arguments, and generates and appends client JavaScript that will call that function with those
            arguments. Here is a contrived example:
        </p>

        <Example captureOutput={['example', 'client-js', 'append-js-call']}>
            <Example.Src lang="javascript" filename="src/index-page.jsx">{
`import { Page } from '@nakedjsx/core/page'

Page.Create('en');
Page.AppendJs(
    function type(thing)
    {
        const t = typeof thing;
        if (t !== 'object')
            return t;
    
        return Array.isArray(thing) ? 'array' : t;
    }
    );
Page.AppendJs(
    function clientLog(...args)
    {
        const pre = document.getElementById('parent');

        for (const arg of args)
            pre.innerText += \`\${type(arg)} arg: \${JSON.stringify(arg)}\n\`;
    });
Page.AppendJsCall('clientLog', 'one', 2, ['three'], { four: 4 });
Page.AppendJsCall('clientLog', 5.5);
Page.AppendBody(
    <>
        <h1>AppendJsCall</h1>
        <pre id="parent" />
    </>
);
Page.Render();`
            }</Example.Src>
        </Example>
    </Topic>

    <Topic name="Using JSX in Client JavaScript" path="jsx">
        <p>
            Client JavaScript can also use JSX. Props are supported, as are
            scoped and nested CSS. Extracted CSS classes are deduplicated with those used by the HTML.
        </p>
        <p>
            Refs and context are not currently supported in client JavaScript.
        </p>
        <p>
            Here is a version of an earlier example converted to use JSX:
        </p>
        
        <Example captureOutput={['example', 'client-js', 'jsx']}>
            <Example.Src lang="javascript" filename="src/index-client.js">{
`const JsxTag =
    ({ count }) =>
    <>
        <br/>
        Click {\`\${count}\`}: This
        <span css="color: fuchsia"> JSX </span>
        content was dynamically added to the DOM.
    </>

var clickCounter = 0;`
            }</Example.Src>
            <Example.Src lang="javascript" filename="src/index-page.jsx">{
`import { Page } from '@nakedjsx/core/page'

Page.Create('en');
Page.AppendBody(
    <>
        <h1 css="color: fuchsia">Title</h1>
        <p onClick="this.appendChild(<JsxTag count={++clickCounter}/>)">Click Me!</p>
    </>
    );
Page.Render(); `
            }</Example.Src>
            <p>The client JSX is compiled down to JavaScript that creates the necessary DOM elements and sets their attributes.</p>
            <p>About 630 bytes is added for the DOM element construction runtime.</p>
            <p>
                The browser <Inline lang="javascript">Element.prototype.appendChild()</Inline> implementation is patched to add support
                for adding an array of elements. Without this, this example would have needed to iterate over the JSX fragment returned by <Inline lang="jsx">{`<JsxTag />`}</Inline>.
            </p>
        </Example>
    </Topic>
</Topic>