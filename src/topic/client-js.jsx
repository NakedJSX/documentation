export default
    () =>
    <Topic name="Client Javascript" path="client-javascript">
        <p>
            NakedJSX can compile JavaScript to execute in the browser.
        </p>

        <Topic name="Dedicated File" path="file">
            <p>
                Files matching the pattern <Inline>*-client.mjs</Inline> are automatically
                compiled and placed into a script tag in the HTML generated by the corresponing <Inline>*-page.jsx</Inline>.
            </p>
            <p>
                Modern JavaScript can be used, with the result being transpiled to a browser-compatible
                format when necessary.
            </p>
            <Example captureOutput={['example', 'client-javascript-introduction']}>
                <Example.Src lang="javascript" filename="src/index-client.js">{
`var p = document.getElementById('click-me');
var clickCounter = 0;
p.onclick =
    () =>
    {
        p.appendChild(document.createElement('br'));
        p.appendChild(document.createTextNode(\`Click \${++clickCounter}: This content was dynamically added to the DOM.\`));
    };`
                }</Example.Src>
                <Example.Src lang="javascript" filename="src/index-page.jsx">{
`import { Page } from '@nakedjsx/core/page'

Page.Create('en');
Page.AppendBody(
    <>
        <h1>Title</h1>
        <p id="click-me">Click Me!</p>
    </>
);
Page.Render();`
                }</Example.Src>
                <p>
                    As you can see, the JavaScript output is minified (although formatted a little because we built with <Inline lang="shell">--pretty</Inline>):
                </p>
            </Example>
            <p>
                Minification is great for production builds, but not during development. In development mode
                (<Inline lang="shell">--dev</Inline>) minification is disabled and sourcemaps are generated,
                providing a comfortable debugging experience.
            </p>
    </Topic>

    <Topic name="JSX" path="jsx">
        <p>
            Client JavaScript can also use JSX. Props are supported, as are
            scoped and nested CSS. Extracted CSS classes are deduplicated with those used by the HTML.
        </p>
        <p>
            Refs and context are not currently supported in client JavaScript.
        </p>
        <p>
            Here is a version of the previous example that uses JSX:
        </p>
        <Example captureOutput={['example', 'client-javascript-jsx']}>
            <Example.Src lang="javascript" filename="src/index-client.js">{
`const JsxTag =
({ count }) =>
<>
    <br/>
    Click {\`\${count}\`}: This
    <span css="color: fuchsia"> JSX </span>
    content was dynamically added to the DOM.
</>

let clickCounter = 0;
let p = document.getElementById('click-me');
p.onclick =
() => p.appendChild(<JsxTag count={++clickCounter}/>);
`
            }</Example.Src>
            <Example.Src lang="javascript" filename="src/index-page.jsx">{
`import { Page } from '@nakedjsx/core/page'

Page.Create('en');
Page.AppendBody(
<>
    <h1 css="color: fuchsia">Title</h1>
    <p id="click-me">Click Me!</p>
</>
);
Page.Render();`
            }</Example.Src>
            <p>The client JSX is compiled down to JavaScript that creates the necessary DOM elements and sets their attributes.</p>
            <p>About 630 bytes is added for the DOM element construction runtime.</p>
            <p>
                The browser <Inline lang="javascript">Element.prototype.appendChild()</Inline> implementation is patched to add support
                for adding an array of elements. Without this, this example would have needed to iterate over the JSX fragment returned by <Inline lang="jsx">{`<JsxTag />`}</Inline>.
            </p>
        </Example>
    </Topic>
</Topic>