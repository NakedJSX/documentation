const appendJsClient =
`var p = document.getElementById('click-me');
var clickCounter = 0;
p.onclick =
    () =>
    {
        p.appendChild(document.createElement('br'));
        p.appendChild(document.createTextNode(\`Click \${++clickCounter}: This content was dynamically added to the DOM.\`));
    };`

const appendJsPage =
`import { Page } from '@nakedjsx/core/page'

Page.Create('en');
Page.AppendBody(
    <>
        <h1>Title</h1>
        <p id="click-me">Click Me!</p>
    </>
);
Page.Render();`

const clientJsxClient =
`const JsxTag =
    ({ count }) =>
    <>
        <br/>
        Click {\`\${count}\`}: This
        <span css="color: fuchsia"> JSX </span>
        content was dynamically added to the DOM.
    </>

var clickCounter = 0;`;

const clientJsxPage =
`import { Page } from '@nakedjsx/core/page'

Page.Create('en');
Page.AppendBody(
    <>
        <h1 css="color: fuchsia">Title</h1>
        <p onClick="this.appendChild(<JsxTag count={++clickCounter}/>)">Click Me!</p>
    </>
    );
Page.Render();`;

export default
    () =>
    <Topic name="Client Javascript" path="client-js">
        <p>
            NakedJSX can compile client JavaScript to execute in the browser, which has two distinct advantages over linking to externally built JavaScript:
        </p>
        <ul>
            <li>NakedJSX compiled client JavaScript can use inline JSX</li>
            <li>The scoped CSS deduplication system allows client and page JSX to share generated classes</li>
        </ul>
        <p>
            By default, compiled client JavaScript is placed in a <Tag>script</Tag> tag
            at the end of the <Tag>body</Tag>. It can also be configured to place it in an asset
            file, with a <Tag>script</Tag> linking to it automatically added to the document <Tag>head</Tag>.
        </p>
        <p>
            There are several ways to get NakedJSX to compile client JavaScript:
        </p>
        <ul>
            <li>A dedicated <Inline>*-client.mjs</Inline> file</li>
            <li>The <Inline lang="js">Page.AppendJs()</Inline> function</li>
            <li>The <Inline lang="js">Page.AppendJsIfNew()</Inline> function</li>
            <li>Adding inline event handlers to JSX elements</li>
            <li>The <Inline lang="js">Page.AppendJsCall()</Inline> function</li>
        </ul>
        <p>
            A dedicated file is usually the right choice for large amounts of code,
            with the other methods used for event handlers, support functions needed
            by custom JSX tags, and other snippets.
        </p>

        <Topic name="Adding via Dedicated File" path="file">
            <p>
                Files matching the pattern <Inline>*-client.mjs</Inline> are automatically
                compiled and placed into a script tag in the HTML generated by the corresponing <Inline>*-page.jsx</Inline>.
            </p>
            <p>
                Modern JavaScript can be used, with the result being transpiled to a browser-compatible
                format when necessary.
            </p>
            <Example captureOutput={['example', 'client-js', 'dedicated-file']}>
                <Example.Src lang="javascript" filename="src/index-client.js">{appendJsClient}</Example.Src>
                <Example.Src lang="javascript" filename="src/index-page.jsx">{appendJsPage}</Example.Src>
                <p>
                    As you can see, the JavaScript output is minified (although it has been formatted a little because we built with <Inline lang="shell">--pretty</Inline>):
                </p>
            </Example>
            <p>
                Minification is great for production builds, but not during development. In development mode
                (<Inline lang="shell">--dev</Inline>) minification is disabled and sourcemaps are generated,
                providing a comfortable debugging experience.
            </p>
        </Topic>

        <Topic name="Adding via Page.AppendJs()" path="page-append-js">
            <p>
                <Inline lang="js">Page.AppendJs(...code)</Inline> adds JavaScript to the page for the browser to execute.
                If multiple arguments are supplied, each will be added to the client JavaScript in turn.
            </p>
            <p>
                A string argument containing JavaScript code is supported, however it is usually a better developer
                experience to pass source <em>directly</em> to <Inline lang="js">Page.AppendJs()</Inline>.
                The page JavaScript compilation process will automatically convert code passed this way to strings
                of code. For example:
            </p>
            <Code lang="js">{
`Page.AppendJs(
    alert('magic!'),
    document.write('code')
    );
Page.AppendJs(console.log('transformation'))`
            }</Code>
            <p>
                Becomes:
            </p>
            <Code lang="js">{
`Page.AppendJs("alert('magic!')", "document.write('code')");
Page.AppendJs("console.log('transformation')");`
            }</Code>
            <p>
                The code has been converted to strings of code, which are later compiled as client JavaScript.
                This ultimately results in this <Tag>script</Tag> being placed the HTML file:
            </p>
            <Code lang="html">{
`<script>
    alert('magic!');
    document.write('code');
    console.log('transformation');
</script>`
            }</Code>

            <Topic name="Appending blocks of code" path="page-append-js-block">
                <p>
                    If you directly add an anonymous or arrow function, then each statement in the body of that function will be added to the top level
                    scope of the client JavaScript. If an unnamed function was added to the client JavaScript there would be no way to invoke it, so
                    NakedJSX repurposes the syntax:
                </p>
                <Example captureOutput={['example', 'client-js', 'append-js', 'anon-function']}>
                    <Example.Src lang="javascript" filename="src/index-page.jsx">{
`import { Page } from '@nakedjsx/core/page'

Page.Create('en');
Page.AppendJs(
    function()
    {
        document.write('zero');
    });
Page.AppendJs(
    () =>
    {
        document.write(' one');
        document.write(' two');
    });
Page.AppendJs(() => document.write(' three'));

Page.AppendBody(<h1>Anon / Arrow Function</h1>);
Page.Render();`
                    }</Example.Src>
                </Example>
            </Topic>
        </Topic>

        <Topic name={'Adding via Inline Event Handlers'} path="on-event-handler">
            <p>
                It's also possible to add client JavaScript using classic inline event handlers on JSX elements:
            </p>
            <Example captureOutput={['example', 'client-js', 'inline-event-handler']}>
                <Example.Src lang="javascript" filename="src/index-page.jsx">{
`import { Page } from '@nakedjsx/core/page'

Page.Create('en');
Page.AppendJs(
    function clicked()
    {   
        alert('You clicked!');
    });
Page.AppendBody(
    <>
        <h1>Event Handler</h1>
        <p onClick="clicked()">Click Me!</p>
    </>
    );
Page.Render();`
                }</Example.Src>
            </Example>
            <p>
                The minified output is a little different here, as the compiler needs to set <Inline lang="js">this</Inline> to the element
                with the inline event handler, and it also needs to pass the event to the handler. A future version of
                NakedJSX may parse the inline handler for references to <Inline lang="js">this</Inline> and <Inline lang="js">event</Inline> and
                simplify the generated code accordingly.
            </p>
        </Topic>

        <Topic name="Adding via Page.AppendJsCall()" path="page-append-js-call">
            <p>
                A common pattern is to pass a named function to <Inline lang="js">Page.AppendJs()</Inline>, and then generate a
                series of calls to that function with differing arguments.
            </p>
            <p>
                While it is possible to manually generate a JavaScript string containg the calls and
                then pass that string to <Inline lang="js">Page.AppendJs()</Inline>, NakedJSX
                provides an easier way.
            </p>
            <p>
                <Inline lang="js">Page.AppendJsCall(functionName, ...args)</Inline> accepts the name of a function followed
                by a series of arguments. It generates and then appends client JavaScript that will call that function with those
                arguments. Here is a contrived example:
            </p>

            <Example captureOutput={['example', 'client-js', 'append-js-call']}>
                <Example.Src lang="javascript" filename="src/index-page.jsx">{
`import { Page } from '@nakedjsx/core/page'

Page.Create('en');
Page.AppendJs(
    function type(thing)
    {
        const t = typeof thing;
        if (t !== 'object')
            return t;
    
        return Array.isArray(thing) ? 'array' : t;
    });
Page.AppendJs(
    function clientLog(...args)
    {
        const pre = document.getElementById('parent');

        for (const arg of args)
            pre.innerText += \`\${type(arg)} arg: \${JSON.stringify(arg)}\n\`;
    });
Page.AppendJsCall('clientLog', 'one', 2, ['three'], { four: 4 });
Page.AppendJsCall('clientLog', 5.5);
Page.AppendBody(
    <>
        <h1>AppendJsCall</h1>
        <pre id="parent" />
    </>
);
Page.Render();`
                }</Example.Src>
            </Example>
        </Topic>

        <Topic name="Using JSX in Client JavaScript" path="jsx">
            <p>
                Client JavaScript can also use JSX. Props are supported, as are
                scoped and nested CSS. Extracted CSS classes are deduplicated with those used by the HTML.
            </p>
            <p>Refs and context are not currently supported in client JavaScript.</p>
            
            <p>Here is a version of an earlier example converted to use JSX:</p>
            <Example captureOutput={['example', 'client-js', 'jsx']}>
                <Example.Src lang="javascript" filename="src/index-client.js">{clientJsxClient}</Example.Src>
                <Example.Src lang="javascript" filename="src/index-page.jsx">{clientJsxPage}</Example.Src>
                <p>The client JSX is compiled down to JavaScript that creates the necessary DOM elements and sets their attributes.</p>
                <p>About 630 bytes is added for the DOM element construction runtime.</p>
                <p>
                    The browser <Inline lang="javascript">Element.prototype.appendChild()</Inline> implementation is patched to add support
                    for adding an array of elements. Without this, this example would have needed to iterate over the JSX fragment returned by <Inline lang="jsx">{`<JsxTag />`}</Inline>.
                </p>
            </Example>
        </Topic>
    </Topic>